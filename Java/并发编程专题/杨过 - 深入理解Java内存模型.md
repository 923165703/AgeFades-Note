# 杨过 - 深入理解Java内存模型

## 什么是 JMM 模型

```shell
# Java Memory Model、抽象概念:
	# 描述一组 规则或规范，
		
	# 定义 各个变量（包括 实例字段、静态字段 和 构成数组对象的元素）的访问方式。
	
# JVM 运行程序的实体是 线程，而每个 线程 创建时，
	# JVM 都会为其创建一个 工作内存（或称为 栈空间），用于存储 线程私有数据，
	
	# 而 Java 内存模型中规定，所有变量 都存储在 主内存，主内存是 共享内存区域，
	
	# 所有线程都可以访问，但 线程对变量的操作（读、取、赋值等）必须在 工作内存 中进行。
	
# 首先将 变量 从 主内存 拷贝到 线程自己的工作空间，
	# 然后对变量进行操作，
	
	# 操作完成后再将 变量 写回 主内存。
	
# 因为 线程 不能直接操作 主内存 中的变量，
	# 线程 工作内存 中存储着 主内存的变量副本拷贝，
	
	# 而 线程工作内存 是每个线程的私有区域数据，
	
	# 所以 不同的线程间 无法访问对方的 工作内存，
	
	# 线程间的通信（传值）必须通过主内存来完成。
```

### JMM 不同于 JVM 内存区域模型

```shell
# JMM 与 JVM 内存区域的划分，是不同的概念层次，
	# JVM 描述的是一组 规则，
	
	# 通过这组 规则 控制程序中 各个变量 在 共享数据区域 和 私有数据区域 的访问方式，
	
	# JMM 是围绕 原子性、有序性、可见性 展开。
	
# JMM 与 Java 内存区域唯一相似点，
	# 都存在 共享数据区域 和 私有数据区域，
	
	# 在 JMM 中，主内存 属于 共享数据区域，从某个程度上讲，包括了 堆和方法区，
	
	# 而 私有数据区域，包括 程序计数器、虚拟机栈、本地方法栈。
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602646146551.png)

#### 主内存

```shell
# 主要存储 Java 实例对象，所有线程创建的 实例对象 都存放在 主内存 中，
	# 不管该 实例对象 是 成员变量 还是 方法区 中的 本地变量（也称局部变量），
	
	# 也包括了 共享的类信息、常量、静态变量。
	
# 由于是 共享数据区域，多条线程 对 同一个变量 进行访问可能会发生 线程安全问题。
```

#### 工作内存

```shell
# 主要存储当前方法的所有本地变量信息（工作内存中存储着主内存中的变量副本拷贝），
	# 每个线程 只能访问自己的 工作内存，
	
	# 即: 线程中的 本地变量 对其他线程是不可见的，
	
	# 就算是 两个线程 执行 同一段代码，也会各自在自己的 工作内存 中创建 本地变量，
	
	# 也包含了 字节码行号指示器、相关 Native 方法的新信息。
	
# 由于是 私有数据区域，线程间无法相互访问工作内存，因此 工作内存数据 不存在 线程安全问题。
```

```shell
# 根据 JVM 虚拟机规范 主内存 与 工作内存 的 数据存储类型 以及 操作方式，
	# 对于一个 实例对象 中的 成员方法 而言，
	
	# 如果方法中包含本地变量是 基本数据类型（boolean/byte/short/char/int/long...）,
		# 将直接存储在 工作内存 的 栈帧结构 中。
	
	# 如果本地变量是 引用类型，该变量的引用会存储在 功能内存 的栈帧中，
		# 而 对象实例 将存储在 主内存（共享数据区域、堆）中。
		
	# 如果是 实例对象的成员变量，不管是 基本数据类型、包装类型、引用类型，
		# 都会被 存储 到堆区。
		
	# 如果是 static变量 以及 类本身相关信息 将会存储在 主内存 中。
	
# 注意:
	# 在 主内存 中的 实例对象，可以被 多线程 共享，
	
	# 假设 两条线程 同时调用了同一个对象的同一个方法，
	
	# 那 两条线程 会将要操作的数据拷贝一份到自己的工作内存中，
	
	# 执行完成操作后才 刷新到主内存。
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602659072182.png)

#### Java内存模型与硬件内存架构的关系

```shell
# 多线程的执行 最终都会映射到 硬件处理器 上进行执行，
	# 但 Java内存模型 和 硬件内存架构 并不完全一致。
	
# 对 硬件内存 来说，只有 寄存器、缓存内存、主内存 的概念，
	# 并没有 工作内存（线程私有数据区域）和 主内存（堆内存）之分，
	
	# 也就是说 Java内存模型 中 内存的划分 对 硬件内存 没有任何影响，
		# 不管是 工作内存 还是 主内存，对硬件来说，都会存储在 计算器主内存 中，
		
		# 也可能存储到 CPU缓存 或 寄存器中。
		
# 总体来说，Java内存模型 和 计算机硬件内存架构 是 相互交叉 的关系，
	# 是一种 抽象概念划分 与 真实物理硬件 的交叉，
	
	# 对于 Java内存区域划分 也是同样道理。
```

#### ![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602660855167.png)

### JMM 存在的必要性

```shell
# 线程安全问题:
	# 假设 A、B 两条线程同时读取 主内存中变量 a=1 到各自线程 工作内存 中,
	
	# A、B 修改 变量a 的值，再写回主内存，
	
	# 就可能造成 线程安全问题，比如 A.a = 2，B.a = 3
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602661113380.png)

```shell
# 以上关于 主内存 与 工作内存 之间的具体交互协议，
	# 即一个变量 如何从 主内存 拷贝到 工作内存、
	
	# 如果从 工作内存 同步到 主内存 之间的实现细节，
	
	# JMM 定义了以下八种操作来完成。
```

### 数据同步八大原子操作

```shell
1. lock(锁定): 
	# 例如: 线程A 标记锁定 主内存中的变量str
	
2. unlock(解锁):
	# 例如: 线程A 解除标记锁定 主内存中的变量str
	
3. read(读取):
	# 例如: 线程A 读取 主内存中的 变量str 到工作内存
	
4. load(载入):
	# 例如: 线程A 拷贝 变量str 到本地变量副本
	
5. use(使用):
	# 例如: 线程A 传输 变量str 到执行引擎
	
6. assign(赋值):
	# 例如: 线程A 接收 执行引擎返回str变量值，并赋值给 工作内存的变量str
	
7. store(存储):
	# 例如: 线程A 传输 变量str 到主内存
	
8. write(写入):
	# 例如: 线程A 传输 变量str值 到主内存，并修改原 变量str 值
```

```shell
# 主内存 -> 工作内存
	# 按顺序执行 read 和 load 操作。
	
# 工作内存 -> 主内存
	# 按顺序执行 store 和 write 操作。
	
# 但 JMM 只要求上述操作 必须按顺序执行，而 没有保证必须是连续执行。
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602662234320.png)

#### 同步规则分析

```shell
# 1. 不允许一个线程 无原因地（没有发生过任何 assign 操作）把数据从 工作内存 同步回 主内存。

# 2. 一个新的变量只能在 主内存中 诞生，
	# 不允许在 工作内存中 直接使用一个 未被初始化（load 或 assign）的变量。
	
	# 即 对一个变量实施 use 或 store 操作之前，必须先自行 assign 和 load 操作。
	
# 3. 一个变量 在 同一时刻 只允许一条线程对其进行 lock 操作，
	# 但 lock 操作可以被 同一线程 重复执行多次，
	
	# 多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
	
	# lock 和 unlock 必须成对出现。
	
# 4. 对一个变量执行 lock 操作，将会清空 工作内存中 此变量的值，
	# 在 执行引擎 使用该变量之前，需要重新执行 load 或 assign 操作 初始化变量值。
	
# 5. 如果 一个变量 事先没有被 lock 锁定，则不允许对它执行 unlock 操作，
	# 也不允许去 unlock 一个被其他线程锁定的变量。
	
# 6. 对一个变量执行 unlock 操作之前，
	# 必须先把 此变量 同步到 主内存中（执行 store 和 write 操作）。
```

### 并发编程的可见性、原子性与有序性问题

#### 原子性

```shell
# 一个操作不可被中断，即使是 多线程环境下，一个操作一旦开始就不会被其他线程影响。

# 在 Java 中，对 基本数据类型 变量的 读取和赋值 操作 是 原子性的。
```

#### 可见性

```shell
# 一个线程 修改了某个 共享变量的值，其他线程能 马上感知修改后的值。

# 对于 串行程序来说，是不存在 可见性概念 的，因为只有一条线程按序执行。

# 多线程环境下，就出现了 可见性问题（写丢失问题）
	# 线程A、B 读取变量 a=1
	
	# 线程A 修改 a=2，write 回主内存
	
	# 线程B 修改 a=3，write 回主内存
	
	# 线程A 读取变量a，发现 a=3，而不是自己改的 a=2，这就是 写丢失问题
```

#### 有序性

```shell
# 多线程环境下，程序执行 可能出现 乱序现象，
	# 因为程序编译成 机器码指令 后，可能会出现 指令重排现象，
	
	# 重排后的指令 与 原指令 的顺序未必一致。
	
# Java 程序中，单线程内 所有操作都被视为 有序性行为，
	# 而 多线程环境下，一个线程 观察 另外一个线程，所有操作都是无序的。
```

### JMM 如何解决原子性&可见性&有序性问题

#### 原子性问题

```shell
# 除了 JVM 自身提供的 对基本数据类型读写 操作的原子性外，
	# 可以通过 synchronized 和 lock 实现原子性，
	
	# 因为 synchronized 和 lock 能够保证 任一时刻 只有一个线程访问该代码块。
```

#### 可见性问题

```shell
# volatile 保证 可见性。

# 当一个 共享变量 被volatile 修饰时，
	# 会保证 修改的值 立即被其他的线程看到，即 修改的值 立即更新到主存中，
	
	# 当其他线程需要读取时，它会去内存中读取新值。
	
# synchronized 和 lock 也可以保证可见性，
	# 因为它们可以保证 任一时刻 只有 一个线程 能访问共享资源，
	
	# 并在其释放锁之前，将修改的变量刷新到内存中。
```

#### 有序性问题

```shell
#  volatile 保证一定的 有序性。

# synchronized 和 lock 保证 有序性。
```

```shell
# 每个线程都有自己的工作内存（类似于 CPU 的高速缓存），
	# JMM 具备一些先天 "有序性"，即 不通过任何手段 就能保证 有序性，
	
	# 这通常被称为 happens-before 原则，
	
	# 如果 两个操作的执行顺序 无法从 happens-before 原则推导出来，
		# 就不能保证 它们的有序性，JVM 就可以随意地对它们进行重排序。
```

```shell
# Java 规范规定 JVM 线程内部 维持 顺序化语义。

# 即: 只要程序的最终结果与它顺序化情况的结果相等，
	# 那么 指令的执行顺序 可以与 代码顺序 不一致，
	
	# 这个过程叫做 指令的重排序。
	
# 指令的重排序意义是什么？
	#  JVM 能根据处理器特性（CPU多级缓存系统、多核处理器等），
	
	# 适当的对 机器指令 进行 重排序，
	
	# 使机器指令更符合 CPU 的执行特性，最大限度的发挥机器性能。
```

![](https://agefades-note.oss-cn-beijing.aliyuncs.com/1602728550517.png)

#### as-if-serial语义

```shell
# 不管怎么重排序（编译器和处理器为了提高并行度），
	# （单线程）程序的执行结果不能被改变。
	
# 编译器、runtime和处理器，都必须遵守 as-if-serial 语义。

# 编译器和处理器 不会对存在 数据依赖关系的操作 做重排序，
	# 因为这种重排序可能会改变 执行结果。
	
	# 反之，不存在 数据依赖关系的操作，就可能被编译器和处理器重排序。
```

#### happens-before 原则

```shell
# 如果只靠 sychronized 和 volatile 来保证原子性、可见性、有序性，
	# 那做 并发程序 就相当麻烦。
	
# 从 JDK1.5 开始，Java使用新的 JSR-133 内存模型，
	# 提供 happens-before 来辅助保证 程序执行 的原子性、可见性、有序性问题，
	
	# 是判断 数据 是否存在竞争、线程是否安全的依据。
```

```shell
1. 程序顺序原则:
	# 单线程内必须保证 语义串行性。
	
2. 锁规则:
	# lock 必须在 unlock 之后（同一个锁）
	
3. volatile 规则:
	# volatile变量 在 每次被线程访问时，都会强制从 主内存 中读取该变量的值，
	
	# 而当变量发生变化时，又会强制将 最新的值 刷新到 主内存，
	
	# 所以，任何时刻 不同线程 总是能看到 volatile变量最新的值。
	
4. 线程启动规则:
	# thread.start() 方法优先于 线程的任何动作，
	
	# 即: thread1 在 thread2.start() 之前修改了共享变量的值，
	
	# thread2.start() 时，可以读到 thread1 修改的共享变量值。
	
5. 传递性:
	#  如果 A > B， B > C， 那么 A > C
	
6. 线程终止规则:
	# thread 所有操作都先于 线程终止。
	
	# thread.join() 方法的作用是，等待 当前执行的线程终止。

	# 假设 thread2 在终止之前，修改了共享变量，
		# thread1 从 thread2 的 join() 方法成功返回后，
		
		# thread2 对共享变量的修改将对 thread1 可见。
		
7: 线程中断规则:
	# 对 thread.interrupt() 方法的调用，
		# 先行发生于 被中断线程的代码 检测到 中断事件的发生，
		
		# 可以通过 thread.inteerrupted() 方法检测线程是否中断。
		
8: 对象终结规则:
	# 对象的构造函数执行，结束 先于 finalize() 方法。
```

## volatile 内存语义

```shell
# JVM 提供的轻量级 同步机制。

# 保证 可见性、禁止指令重排，不保证原子性。
```

### volatile 的可见性

### volatile 无法保证原子性

### volatile 禁止重排优化

### 硬件层的内存屏障

### volatile 内存语义的实现