# 周阳 - 阿里P6面试

## JUC 多线程及高并发

### 请谈谈你对 volatile 的理解

```shell
# volatile 是 Java 虚拟机提供的轻量级的同步机制。
	# 保证可见性
	# 不保证原子性
		# A 线程写操作并同步到主存后，通知到其他线程这个时间差上，别的线程也同步写操作到主存上
		# 这就是没有保证原子性，出现了写覆盖
		# 如何解决原子性问题？
			# 加 sycnchronized
			# 用 AtomicInteger<推荐>
	# 禁止指令重排
		# 利用内存屏障<Memory Barrier，一个 CPU 指令>,它的两个作用
        	# 保证特定操作的执行顺序
        	# 保证某些变量的内存可见性<即 volatile 保证可见性的来源>
```

#### volatile 可见性代码验证

```java
import java.util.concurrent.TimeUnit;

public class VolatileDemo {

    public static void main(String[] args) {
        User user = new User();
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t come in");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            user.add();
            System.out.println(Thread.currentThread().getName() + "\t num value : " + user.num);
        }, "SyncThread").start();

        while (user.num == 0) {}
        System.out.println(Thread.currentThread().getName() + "\t over,num value : " + user.num);
    }

}

class User {
    volatile int num = 0; // 去掉 volatile 试试
    void add() {
        this.num = 60;
    }
}
```

#### volatile 不保证原子性代码验证

```java
public class VolatileDemo {

    public static void main(String[] args) {
        User user = new User();
        for(int i = 1;i <= 20; i++ )
        {
            new Thread(() -> {
                for (int j = 1; j <= 1000; j++) {
                    user.add();
                }
            },String.valueOf(i)).start();
        }
        while (Thread.activeCount() > 2){
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName() + "\t over,num value : " + user.num);
    }
}

class User {
    volatile int num = 0;
    void add() {
        num++;
    }
}
```

```shell
# javap -c 配置 https://jingyan.baidu.com/article/f71d6037c05ecc1ab741d163.html
# 利用 javap -c 命令编译得出字节码 i++ 实际指令数及步骤为 : 
```

![UTOOLS1569217383589.png](https://i.loli.net/2019/09/23/jWMfVpSErCaiPg3.png)

#### 请谈谈你对 JMM 的理解

```shell
# JMM<Java Memory model | Java 内存模型>
	# 抽象概念，并不真实存在。
	# 它描述一组规则或规范。
	# 通过这组规范定义了程序中各个变量(包括实例字段、静态字段和构成数组对象的元素)的访问方式
	
# JMM 关于同步的规定
	# 线程解锁前，必须把共享变量的值刷新回主内存。
	# 线程加锁前，必须读取主内存的最新值到自己的工作内存。
	# 加锁解锁是同一把锁。
	
# 可见性 : A B 线程各自拷贝主存变量并操作，先写回主存的值一定要通知给另外的线程
    # 而 JMM 中线程可见性的实现是由 : 
        # Volatile
        # Synchronized
        # final 来实现的
        
# 原子性 : 即某个线程正在做某个具体业务时，中间不可以被加塞或者被分隔
	# 要么同时成功，要么同时失败
	
# 有序性 : 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排
	# 一般分为以下三种
		# 源代码 -> [编译器优化的重排] -> [指令并行的重排] -> [内存系统的重排] -> 最终执行指令
	# 单线程环境确保程序最终执行结果和代码顺序执行的结果一致
	# 处理器在进行重排序时必须要考虑指令之间的 数据依赖性
	# 多线程环境中线程交替执行，此时编译器优化重排就可能导致，多个线程使用的同一个变量无法保证一致性。
	
# 由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存<线程栈>。
	# 工作内存是每个线程的私有数据区域。
	# 而 JMM 中规定所有变量都存储在 主内存 中，即所有线程都可以访问。
	# 但线程对变量的操作(读写)必须在工作内存中进行。
	# 流程
        # 线程栈本地内存
        # -> 从主内存中拷贝变量
        # -> 对本地内存中的变量进行读写操作
        # —> 操作完成后再将其写会主内存
    # 因此，不同的线程间无法直接互访，线程间的通信必须通过主内存来完成。
```

![UTOOLS1569205680742.png](https://i.loli.net/2019/09/23/3CIPLJovnMZsQl1.png)

#### 你在哪些地方用到过 volatile

```shell
# 单例模式 DCL<Double Check Lock 双端检锁机制> 代码

# instance = new SingletonDemo() 是被分成以下 3 步完成
	# memory = allocate();     分配对象内存空间
	# instance(memory);        初始化对象
	# instance = memory;	   设置 instance 指向刚分配的内存地址，此时 instance != null
	
	# 步骤2 和 步骤3 不存在数据依赖关系，重排与否的执行结果单线程中是一样的
	# 这种指令重排是被 Java 允许的
	# 当 3 在前时，instance 不为 null，但实际上初始化工作还没完成，
		# 会变成一个返回 null 的getInstance
```

```java
public class SingletonDemo {
    private static volatile SingletonDemo instance; // volatile 防止重排序

    private SingletonDemo() {
        System.out.println(Thread.currentThread().getName() + "\t get instance");
    }
    
    public static SingletonDemo getInstance() {
        if (instance == null) {
            synchronized (SingletonDemo.class) {
                if (instance == null)
                    instance = new SingletonDemo();
            }
        }
        return instance;
    }

    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            new Thread(() -> {
                getInstance();
            }, String.valueOf(i)).start();
        }
    }
}
```

### 请谈谈你对 CAS 的理解

```shell
# CAS 是什么？
	# 答: 比较并交换<compareAndSet>,它是一条 CPU 并发原语
		# 它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子性的。
	
	# 例: AtomicInteger 的 compareAndSet('期望值','设置值') 方法
		# 期望值与目标值一致时，修改目标变量为设置值
		# 期望值与目标值不一致时，返回 false 和最新主存的变量值
		
# CAS 的底层原理
	# 例: AtomicInteger.getAndIncrement()
	# 调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令
		# 这是一种完全依赖于硬件的功能，通过它实现原子操作。
		# 原语的执行必须是连续的，在执行过程中不允许被中断，CAS 是 CUP 的一条原子指令。
```

#### AtomicInteger.getAndIncrement() 方法详解

![UTOOLS1569231184344.png](https://i.loli.net/2019/09/23/fym1bIkcrhOUgl7.png)

```java
/**
 * unsafe: rt.jar/sun/misc/Unsafe.class
 *   Unsafe 是 CAS 的核心类，由于 Java 无法直接访问底层系统，需要通过本地<native>方法来访问
 *	 Unsafe 相当于一个后门，基于该类可以直接操作特定内存的数据
 *	 Unsafe 其内部方法都是 native 修饰的，可以像 C 的指针一样直接操作内存
 *	 Java 中的 CAS 操作执行依赖于 Unsafe 的方法，直接调用操作系统底层资源执行程序
 *
 * this: 当前对象
 *	 变量 value 由 volatile 修饰，保证了多线程之间的内存可见性、禁止重排序
 *
 * valueOffset: 内存地址
 *	 表示该变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据
 *
 * 1: 固定写死，原值加1
 */
public final int getAndIncrement(){
    return unsafe.getAndAddInt(this,valueOffset,1);
}

/**
 * Unsafe.getAndAddInt()
 * getIntVolatile: 通过内存地址去主存中取对应数据
 * 
 * while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4)):
 * 	 将本地 value 与主存中取出的数据对比，如果相同，对其作运算，
 * 		此时返回 true，取反后 while 结束，返回最终值。
 * 	 如果不相同，此时返回 false，取反后 while 循环继续运行，此时为自旋锁<重复尝试>
 *		由于 value 是被 volatile 修饰的，所以拿到主存中最新值，再循环直至成功。
 */
public final int getAndAddInt(Object var1,long var2,int var4){
    int var5;
    do{
        var5 = this.getIntVolatile(var1,var2); // 从主存中拷贝变量到本地内存
    } while(!this.compareAndSwapInt(var1,var2,var5,var5 + var4));
    return var5;
}
```

#### CAS 代码演示

```java
public class CASDemo {

    public static void main(String[] args) {
        AtomicInteger num = new AtomicInteger(5);
        // TODO
        System.out.println(num.compareAndSet(5, 1024) + "\t current num" + num.get());
        System.out.println(num.compareAndSet(5, 2019) + "\t current num" + num.get());
    }
```

#### CAS 缺点

```shell
# 如果 CAS 长时间一直不成功，会给 CPU 带来很大的开销

# 只能保证一个共享变量的原子操作

# 引出了 ABA 问题
```

### 请你谈谈原子类的ABA问题、原子更新引用问题

#### ABA 问题

```shell
# CAS 会导致 ABA 问题

# CAS 算法实现一个重要前提
	# 去除内存中某时刻的数据，并在当下时刻比较并替换
	# 那么这个时间差内会导致数据的变化
	
# 例: A、B线程从主存取出变量 value
	# -> A 在 N次计算中改变 value 的值
	# -> A 最终计算结果还原 value 最初的值
	# -> B 计算后，比较主存值与自身 value 值一致，修改成功
	
# 尽管各个线程的 CAS 都操作成功，但是并不代表这个过程就是没有问题的
```

#### ABA问题代码验证

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public class ABADemo{

    static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);

    public static void main(String[] args) {
        new Thread(() -> {
            atomicReference.compareAndSet(100,101);
            atomicReference.compareAndSet(101,100);
            },"AtomicReference Thread 1").start();

        new Thread(() -> {
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            System.out.println(atomicReference.compareAndSet(100, 101) + "\t" + atomicReference.get());
        },"AtomicReference Thread 2").start();
    }

}
```

#### 原子引用问题

```shell
# java.util.concurrent.atomic.AtomicReference
	# Class AtomicReference<V> : 原子引用，V 为需要包装的泛型
```

##### 原子引用验证代码

```java
@Getter
@ToString
@AllArgsConstructor
class User{
    String username;
    int age;
}

public class AtomicReferenceDemo {

    public static void main(String[] args) {
        User tony = new User("tony",20);
        User tom = new User("tom",25);

        AtomicReference<User> reference = new AtomicReference<>();
        reference.set(tony);
        System.out.println(reference.compareAndSet(tony, tom) + "\t user : " + reference.get().toString());
        System.out.println(reference.compareAndSet(tony, tom) + "\t user : " + reference.get().toString());

    }

}
```

#### 时间戳原子引用解决 ABA 问题

```shell 
# java.util.concurrent.atomic.AtomicStampedReference
	# Class AtomicStampedReference<V> : 时间戳原子引用，V 为需要包装的泛型
```

#### 时间戳原子引用解决 ABA 问题代码验证

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicStampedReference;

public class ResolveABADemo {

    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 1);

    public static void main(String[] args) {
        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + "初始版本号" + stamp);
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
            System.out.println(Thread.currentThread().getName() + "结束版本号" + atomicStampedReference.getStamp());
        }, "AtomicStampedReference Thread 1").start();

        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + "初始版本号" + stamp);
            try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
            boolean result = atomicStampedReference.compareAndSet(100, 101, stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName() + "结束版本号" + atomicStampedReference.getStamp() + "\t CAS 操作结果 : " + result);
            System.out.println("最终主存值为 : " + atomicStampedReference.getReference() + "\t 最终版本号为 : " + atomicStampedReference.getStamp());
        }, "AtomicStampedReference Thread 2").start();
    }

}
```

### 请编码一个不安全的ArrayList 案例并给出解决方案

