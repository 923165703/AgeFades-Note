# 硅谷 - 数据结构和算法

## 数据结构和算法内容介绍

### 几个经典的算法面试题

```shell
# 字符串匹配问题
	# str1 = "你快乐吗快乐吗快乐你乐吗"， str2 = "快乐你你你乐快吗你快乐吗"
		# 最快的速度匹配，str1 是否包含 str2，如果存在，就返回第一次出现的位置，如果没有，则返回 -1
	
	# 解决思路:
		# 暴力匹配
		# KMP 算法<部分匹配表>
```

```shell
# 汉诺塔游戏
	# 将 A 塔所有圆盘移动到 C 盘，并且小圆盘上不能放大圆盘，三个柱子之间一次只能移动一个圆盘。
```

![UTOOLS1575600574554.png](https://img01.sogoucdn.com/app/a/100520146/cdf9253c3623f8066a48440528a75923)

```shell
# 八皇后问题
	# 回朔算法的典型案例
	# 在 8x8 格的国际象棋上摆放八个皇后，使其不能互相攻击
	# 即: 任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
```

![UTOOLS1575600691256.png](https://img03.sogoucdn.com/app/a/100520146/d1374e90f3a35baf2d0ed942f2a7461c)

```shell
# 马踏棋盘<骑士周游>
	# 将马随机放在国际象棋的 8x8 棋盘的某个放个中，马走日进行移动，要求每个方格只进入一次，走遍棋盘上全部 64 个方格
	# 图的深度优化遍历算法<DFS> + 贪心算法优化
```

![UTOOLS1575600813113.png](https://img04.sogoucdn.com/app/a/100520146/1c12369b2be1b9b6940a000c70dc8353)

### 数据结构和算法的重要性

```shell
# 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高度计算。
```

## 数据结构和算法概述

### 数据结构和算法的关系

```shell
# 数据结构是一门研究组织数据方式的学科

# 程序 = 数据结构 + 算法

# 数据结构是算法的基础
```

### 线性结构和非线性结构

```shell
# 数据结构包括:
	# 线性结构和非线性结构
```

#### 线性结构

```shell
# 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。

# 线性结构有两种不同的存储结构，即顺序存储结构<数组> 和链式存储结构<链表>。
	# 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。
	
	# 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。
	
# 常见的线性结构有:
	# 数组、队列、链表和栈。
```

#### 非线性结构

```shell
# 非线性结构包括:
	# 二维数组
	# 多维数组
	# 广义表
	# 树结构
	# 图结构
```

## 稀疏数组和队列

### 稀疏数组

#### 五子棋的问题

```shell
# 编写的五子棋程序中，有存盘退出和续上盘的功能。
```

![UTOOLS1575601280168.png](https://img02.sogoucdn.com/app/a/100520146/6d14f3f9d428798a01297d7913c53f65)

##### 问题分析

```shell
# 因为该二维数组的很多值都是默认值 0，因此记录了很多没有意义的数据 
```

#### 基本介绍

```shell
# 当一个数组中大部分元素为 0，或者为同一个值得数组时，可以使用稀疏数组来保存该数组。

# 稀疏数组的处理方法是:
	# 记录数组一共有几行几列，有多少个不同的值
	# 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小存储数据结构的规模
```

![UTOOLS1575601473254.png](https://img01.sogoucdn.com/app/a/100520146/8cb9d50ec316dd8d6fc6d0f521a89b79)

#### 思路分析

```shell
# 二维数组 转 稀疏数组的思路
	# 遍历原始的二维数组，得到有效数据的个数 sum ->
		# 根据 sum 就可以创建 稀疏数组 sparseArr int[sum+1][3] ->
		# 将二维数组的有效数据存入到稀疏数组
		
# 稀疏数组转原始的二维数组的思路
	# 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
	# 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可
```

#### 代码验证

```java
public class SparseArray {

    public static void main(String[] args) {
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子 1: 表示黑子 2: 表示蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;

        // 输出原始数组
        Arrays.stream(chessArr1)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

        // 得到二维数组非 0 个数
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }

        // 将二维数组 转 稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组，将非 0 的值存放到 sparseArr
        int count = 0; // 记录第几个非 0 数据
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }

        System.out.println("----------------------");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        System.out.println("----------------------");
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        Arrays.stream(chessArr2)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

    }

}
```

### 队列

#### 介绍

```shell
# 队列是一个有序列表，可以用 数组 或是 链表来实现

# 遵循 先入先出 的原则。

# 数组模拟队列示意图:
```

![UTOOLS1575610263678.png](https://img03.sogoucdn.com/app/a/100520146/ad34e99ce46f9b61e005e0872f82b7a5)

#### 数组模拟队列思路

```shell
# 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图
	# 其中 maxSize 是该队列的最大容量
	
# 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量
	# front 记录队列前端下标，会随着数据输出而改变
	# rear 记录队列后端的下标，而 rear 则是随着数据输入而改变
```

![UTOOLS1575611292864.png](https://img04.sogoucdn.com/app/a/100520146/be0ad51bf50e681cc155101f33573580)

```shell
# 当我们将数据存入队列时称为 "addQueue"
	# 将尾指针往后移: rear + 1，当 front == rear 【空】
	# 若尾指针 rear 小于队列的最大下标 maxSize-1 ->
		# 则将数据存入 rear 所指的数组元素中，否则无法存入数据 ->
		# rear == maxSize -1 【队列满】
```

```java
public class ArrayQueue {

    // 数组的最大容量
    private int maxSize;

    // 队列头
    private int front;

    // 队列尾
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; // 指向队列头部，分析出 front 是指向队列头的前一个位置
        rear = -1; // 指向队列尾，即队列最后一个数据
    }

    // 判断队列是否满
    public boolean isFull(){
        return rear == maxSize - 1;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        rear ++; // 尾指针后移
        arr[rear] = n;
    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        front ++; // 头指针后移
        return arr[front];
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front + 1];
    }

}
```

#### 问题分析并优化

```shell
# 目前数组使用一次就不能用，没有达到优化的效果

# 将这个数组改进成一个 环形的队列 <取模: %>
```

#### 思路分析

```shell
# 尾索引的下一个为头索引时表示队列满
	# 即将队列容量空出一个作为约定
	# 在做判断队列满的时候需要注意 
		# (rear + 1) % maxSize == front【满】
		# rear == front【空】
		
# 分析示意图:
```

![UTOOLS1575616062211.png](https://img01.sogoucdn.com/app/a/100520146/4a089304087b0e969b7471352245fc28)

##### 思路如下

```shell
# front 变量的含义做一个调整:
	# front 就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，初始值为 0
	
# rear 变量的含义做一个调整:
	# rear 指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定
	# read 的初始值为 0
	
# 当队列满时，条件是(rear + 1) % maxSize = front【满】

# 当队列为空时，rear == front【空】

# 队列中有效的数据个数:
	# (rear + maxSize - front) % maxSize
	# rear = 1，front = 0
	
# 这样在原来的队列上修改得到，一个环形队列
```

```java
public class CircleArray {

    // 数组的最大容量
    private int maxSize;

    // 队列头，初始值为 0
    private int front;

    // 队列尾，初始值为 0
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    // 判断队列是否满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        // 加入数据
        arr[rear] = n;
        // 移动 rear 指针
        rear = (rear + 1) % maxSize;

    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front % maxSize];
    }

    // 当前队列有效数据的个数
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

}
```

## 链表

### 介绍

```shell
# 链表是有序的列表，但是它在内存中是存储如下:
```

![UTOOLS1575617283864.png](https://img01.sogoucdn.com/app/a/100520146/e970726ccadf5d64d579da7a3719a2a3)

```shell
# 链表是以节点的方式来存储，是链式存储

# 每个节点包含 data 域，next 域<指向下一个节点>

# 链表的各个节点不一定是连续存储

# 链表分 带头节点的链表 和 没有头节点的链表
```

#### 带头节点逻辑示意图

![UTOOLS1575617501182.png](https://img03.sogoucdn.com/app/a/100520146/4ae1eea1f7e8fba92f736a0ecd2af09b)

### 单链表的应用实例

```java
public class SingleLinkedList {

    // 初始化一个虚拟头结点
    private HeroNode head = new HeroNode(0,"");

    // 不考虑编号顺序，直接添加到单链表的最后节点
    public void add(HeroNode node) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null)
                break;
            temp = temp.next;
        }
        temp.next = node;
    }

    // 根据排名将英雄插入到指定位置，如有这个排名，则添加失败
    public void addByOrder(HeroNode node) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no > node.no)
                break;
            else if (temp.next.no == node.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            System.out.printf("%d 已存在，不能加入\n", node.no);
        else {
            node.next = temp.next;
            temp.next = node;
        }
    }

    // 根据 no 编号修改节点信息
    public void update(HeroNode node) {
        if (isEmpty())
            throw new RuntimeException("the likedList is empty");
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp == null)
                break;
            if (temp.no == node.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.name = node.name;
        else
            throw new RuntimeException("the node was not found");
    }

    // 删除节点
    public void del(int no) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.next = temp.next.next;
        else
            throw new RuntimeException("the node was not found");
    }

    // 显示链表
    public void showList(){
        if (isEmpty()n
            throw new RuntimeException("the linkedList is empty");
        HeroNode temp = head.next;
        while(true) {
            if (temp == null)
                break;
            System.out.println(temp);
            temp = temp.next;
        }
    }

    // 判断链表是否为空
    public boolean isEmpty(){
        return head.next == null;
    }

}

class HeroNode {

    public int no;
    public String name;
    public HeroNode next;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 单链表面试题

#### 求单链表中有效节点的个数

```java
/**
 * 获取到单链表的节点的个数<如果是带头结点的链表，需求不统计头节点>
 * @param head : 链表的头结点
 * @return : 返回有效节点的个数
 */
public static int getLength(HeroNode head) {
  	if (head.next == null)
    	return 0;
  
 	  int length = 0;
  	HeroNode cur = head.next;
    while (cur != null) {
      length++;
      cur = cur.next;
    }
  
  	return length;
}
```

#### 查找单链表中的倒数第 k 个节点

```java
/**
 * param : 参数接收 head 节点，同时接收一个 index
 * 思路 : 先从头到尾遍历节点，得到链表的总长度
 *				 size - index 即倒数第 k 个节点
 */
public static HeroNode findLastIndexNode(HeroNode head, int index) {
  	// 判断如果链表为空，返回 null
  	if (isEmpty())
      throw new RuntimeException("the linkedList is empty");
  	// 获取链表长度
  	int size = getLength(head);
  	// index 值校验
    if (index <= 0 || index > size)
      throw new RuntimeException("the index is illegal");
  
  	HeroNode cur = head.next;
   	for (int i = 0; i < size - index; i++) {
      cur = cur.next;
    }
  	return cur;
}
```

#### 单链表的反转

```shell
# 思路:
	# 先定义一个节点 reverseHead
	# 从头到尾遍历链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端
	# 原来的链表的 head.next = reverseHead.next
```

```java
public static void reverseList(HeroNode head) {
		// 判断是否需要反转
    if (head.next == null || head.next.next == null) {
      return;
    }
		
    HeroNode cur = head.next;	// 取出当前链表的第一个节点作为初始化当前节点
    HeroNode next = null;
    HeroNode reverseHead = new HeroNode(0, "");	// 定义虚拟链表头辅助变量

    while (cur != null) {	// 遍历条件，原链表的 next 节点不为空时
      next = cur.next;	// 将辅助变量指向当前节点的下一个节点
      cur.next = reverseHead.next;	// 将 reverseHead 头结点的 next 赋值给当前节点的 next
      reverseHead.next = cur;	// 将当前节点赋值给 reverseHead 的 next
      cur = next;	// 后移当前节点的位置
    }

    head.next = reverseHead.next;	// 切换头结点
}
```

#### 从尾到头打印单链表

##### 思路

```shell
# 要求就是逆序打印单链表

# 方法1:
	# 先将单链表进行反转操作，然后再进行遍历即可。
	# 问题: 会破坏原来的单链表结构，不建议
	
# 方法2:
	# 利用 栈 这个数据结构，将各个节点压入到 栈 中
	# 然后利用 栈 的 先进后出 的特点，实现逆序打印的效果
```

```java
public static void reversePrint(HeroNode head) {
  	if (head.next == null) {
      return;
    }
  	Stack<HeroNode> stack = new Stack<>();
  	HeroNode cur = head.next;
  	while (cur != null) {
      stack.push(cur);
      cur = cur.next;
    }
  	while (stack.size() > 0) {
      System.out.println(stack.pop());
    }
}
```

#### 合并两个有序的单链表，合并之后的链表依然有序

```java
@Data
@ToString
class Node {

    int val;
    Node next;

    public Node(int val) {
        this.val = val;
    }

    public static Node mergeTwoLists(Node n1, Node n2){
      	// 判断某个链表是否为空，空值直接返回另一个链表
        if (n1 == null) return n2;
        if (n2 == null) return n1;

        Node head = null;	// 定义新的头节点
        if (n1.val <= n2.val) {	// 默认升序比较
            head = n1;	// 将小值赋值给 head
            head.next = mergeTwoLists(n1.next, n2); // 递归比较，获取下个小值
        } else {
            head = n2;
            head.next = mergeTwoLists(n2.next, n1);
        }
        return head;
    }
}
```

### 双向链表应用实例

```shell
# 管理单向链表的缺点分析:
	# 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
	# 单向链表不能自我删除，需要靠辅助节点。
	# 而双向链表，则可以自我删除。
```

#### 代码实例

```java
public class DoubleLinkedList {

    private Node head = new Node(0, "");

    public Node getHead() {
        return head;
    }

    public void list() {
        if (head.next == null) throw new RuntimeException("the list is empty");

        Node temp = head.next;
        while (true) {
            if (temp == null) break;

            System.out.println(temp);
            temp = temp.next;
        }
    }

    public void add(Node node) {
        Node temp = head;
        while (true) {
            if (temp.next == null) break;
            temp = temp.next;
        }
        temp.next = node;
        node.pre = temp;
    }

    public void update(Node node) {
        if (head.next == null) throw new RuntimeException("the list is empty");

        Node temp = head.next;
        boolean flag = false;

        while (true) {
            if (temp == null) break;
            if (temp.val == node.val) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) temp.name = node.name;
        else throw new RuntimeException("the node was not found");
    }

    public void del(int val) {
        if (head.next == null) throw new RuntimeException("the list is empty");
        Node temp = head.next;
        boolean flag = false;

        while (true) {
            if (temp == null) break;
            if (temp.val == val) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            temp.pre.next = temp.next;
            if (temp.next != null) temp.next.pre = temp.pre;
        } else {
            throw new RuntimeException("the node was not found");
        }
    }

}

class Node {

    public int val;
    public String name;
    public Node pre;
    public Node next;

    public Node(int val, String name) {
        this.val = val;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Node{" +
                "val=" + val +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 单向环形链表应用场景

#### Josephu 问题

```shell
# 约瑟夫问题:
	# 设编号为 1，2,... n 的 n 个人围坐一圈，约定编号为 k（1 <= k <= n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
```

#### 思路分析

```shell
# 用一个不带头节点的循环链表来处理 Josephu 问题

# 先构成一个有 n 个节点的单循环链表，然后由 k 节点起从 1 开始计数
	# 计数到 m 时，对应节点从链表中删除
	# 然后再从被删除节点的下一个节点又从 1 开始计数，直到最后一个节点从链表中删除
	# 算法结束
```

#### 单向环形链表

![UTOOLS1575870350039.png](https://img02.sogoucdn.com/app/a/100520146/72ec8b1cfbd4f05ad2a2ca9ec5f252e4)

#### 代码实现

```java
public class Joseph {

    public static void main(String[] args) {
        CircleSingleLinkedList list = new CircleSingleLinkedList();
        list.add(125);
        list.show();
        list.josephOut(10, 20, 125);
    }

}

class CircleSingleLinkedList {

    private Node first = null;

    public void add(int nums) {
        if (nums < 1) throw new RuntimeException("the parameter is illegal");
        Node cur = null;
        for (int i = 1; i <= nums; i++) {
            Node node = new Node(i);
            if (i == 1) {
                first = node;
                first.next = first;
                cur = first;
            } else {
                cur.next = node;
                node.next = first;
                cur = node;
            }
        }
    }

    public void show() {
        if (first == null) throw new RuntimeException("the list is empty");

        Node temp = first;
        while (true) {
            System.out.printf("节点编号%d\n", temp.no);
            if (temp.next == first) break;
            temp = temp.next;
        }
    }

    /**
     * 约瑟夫问题出圈顺序
     * @param startNo : 表示从第几个节点开始
     * @param countNum : 表示数几个节点
     * @param nums  : 表示最初有多少个节点
     */
    public void josephOut(int startNo, int countNum, int nums) {
        if (first == null || startNo < 1 || startNo > nums)
            throw new RuntimeException("the parameter is illegal");

        Node temp = first;
        while (true) {
            if (temp.next == first) break;
            temp = temp.next;
        }

        for (int j = 0; j < startNo - 1; j++) {
            first = first.next;
            temp = temp.next;
        }

        while (true) {
            if (temp == first) break;
            for (int j = 0; j < countNum -1; j++){
                first = first.next;
                temp = temp.next;
            }
            System.out.printf("Node %d 出圈\n", first.no);
            first = first.next;
            temp.next = first;
        }

        System.out.printf("最后留在圈中的节点编号 %d\n", first.no);
    }

}

class Node {
    public int no;
    public Node next;

    public Node(int no) {
        this.no = no;
    }
}
```

## 栈

### 栈的介绍

```shell
# Stack:
	# 栈是一个 先入后出（FILO - First In Last Out）的有序列表
	# 栈是限制 线性表中，元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。
	# 允许 插入和删除 的一端，为变化的一端，称为 栈顶（Top）
	# 另一端为固定的一段，称为栈底（Bottom）
	
# 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶
	# 而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
	
# 图解说明 出栈（pop）和 入栈（push）的概念:
```

![UTOOLS1575874225948.png](https://img04.sogoucdn.com/app/a/100520146/2194eebff7c351b0b4d4c1a1f4b19e0f)

### 栈的应用场景

```shell
# 子程序的调用:
	# 在跳往子程序前，会先将下个指令的地址存到栈中
	# 直到子程序执行完后再将地址取出，以回到原来的程序中
	
# 处理递归调用:
	# 和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入栈中
	
# 表达式的转换（中缀表达式转后缀表达式）和求值（实际解决）

# 二叉树的遍历

# 图形的深度优先（depth - first）搜索法
```

### 栈的快速入门

```shell
# 用数组模拟栈的使用
```

#### 思路分析

```shell
# 使用数组来模拟栈

# 定义一个 top 来表示栈顶，初始化为 -1

# 入栈的操作，当有数据加入到栈时，top++; stack[top] = data;

# 出栈的操作，int value = stack(top); top--; return value; 
```

#### 示意图

![UTOOLS1575874595743.png](https://img04.sogoucdn.com/app/a/100520146/d31c5dfd37d93ac6b61d6c1721076ad0)

#### 代码实现

```java
public class ArrayStack {

    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public void push(int val) {
        if (isFull()) throw new RuntimeException("the stack is full");
        top++;
        stack[top] = val;
    }

    public int pop() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        int val = stack[top];
        top--;
        return val;
    }

    public void show() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

}
```

### 栈实现综合计算器（中缀表达式）

#### 思路分析

```shell
# 通过一个 index 值（索引），来遍历我们的表达式

# 如果我们发现是一个数字，就直接入数栈

# 如果发现扫描到是一个符号，就分如下情况:
	# 如果发现当前的符号栈为空，就直接入栈
	# 如果符号栈有操作符，就进行比较
		# 如果当前的的操作符的优先级小于或者等于栈中的操作符
			# 就需要从数栈中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算
			# 将得到结果，入数栈，然后将当前的操作符入符号栈
		
		# 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
		
# 当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并运行

# 最后在数栈只有一个数字，就是表达式的结果
```

#### 示意图

![UTOOLS1575875907763.png](https://img03.sogoucdn.com/app/a/100520146/acecaafbf55167a46a7b84d82fae413a)

#### 代码实例

```java
public class Calculator {

    public static void main(String[] args) {

        String expression = "7*2*2-5+1-5+3-4";
        ArrayStack num = new ArrayStack(10);
        ArrayStack ope = new ArrayStack(10);

        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch;
        String keepNum = "";

        while (true) {
            ch = expression.substring(index, index + 1).charAt(0);
            if (ope.isOperator(ch)) {
                if (!ope.isEmpty()) {
                    if (ope.priority(ch) <= ope.priority(ope.peek())) {
                        num1 = num.pop();
                        num2 = num.pop();
                        oper = ope.pop();
                        res = num.cal(num1, num2, oper);
                        num.push(res);
                        ope.push(ch);
                    } else {
                        ope.push(ch);
                    }
                } else {
                    ope.push(ch);
                }
            } else {
                keepNum += ch;
                if (index == expression.length() - 1) {
                    num.push(Integer.parseInt(keepNum));
                } else {
                    if (ope.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {
                        num.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }
            }

            index++;
            if (index >= expression.length()) break;
        }

        while (true) {
            if (ope.isEmpty()) break;
            num1 = num.pop();
            num2 = num.pop();
            oper = ope.pop();
            res = num.cal(num1, num2, oper);
            num.push(res);
        }

        int result = num.pop();
        System.out.printf("表达式: %s = %d", expression, result);
    }

}

class ArrayStack {

    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[this.maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public int peek() {
        return stack[top];
    }

    public void push(int val) {
        if (isFull()) throw new RuntimeException("the stack is full");
        top++;
        stack[top] = val;
    }

    public int pop() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        int val = stack[top];
        top--;
        return val;
    }

    public void show() {
        if (isEmpty()) throw new RuntimeException("the stack is empty");
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

    public int priority(int operator) {
        if (operator == '*' || operator == '/') return 1;
        else if (operator == '+' || operator == '-') return 0;
        else return -1;
    }

    public boolean isOperator(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    public int cal(int num1, int num2, int operator) {
        int res = 0;

        switch (operator) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

}
```

### 逆波兰计算器

```shell
# 输入一个逆波兰表达式（后缀表达式），使用栈（Stack）计算其结果

# 例如: (3+4)x5-6 对应的后缀表达式就是 3 4 + 5 x 6 -

# 思路分析:
	# 从左至由扫描，将 3 和 4 压入堆栈
	# 遇到 + 运算符，因此弹出 4 和 3，计算得 7 再入栈
	# 将 5 入栈
	# 接下来是 x 运算法，弹出 5 和 7，计算得 35 入栈
	# 将 6 入栈
	# 最后是 - 运算符，弹出 35 和 6，计算得 29，即最终结果
```

#### 代码实例

```java
public class PolandNotation {

    public static void main(String[] args) {
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";

        List<String> list = getListString(suffixExpression);
        System.out.println("rpnList = " + list);
        int res = calculate(list);

        System.out.println("result = " + res);
    }

    private static int calculate(List<String> list) {
        Stack<String> stack = new Stack<>();
        list.forEach(s -> {
            if (s.matches("\\d+")) stack.push(s);
            else {
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                switch (s){
                    case "+":
                       res = num1 + num2;
                       break;
                    case "-":
                        res = num1 - num2;
                        break;
                    case "*":
                        res = num1 * num2;
                        break;
                    case "/":
                        res = num1 / num2;
                        break;
                    default:
                        throw new RuntimeException("运算符有误");
                }
                stack.push(res + "");
            }
        });
        return Integer.parseInt(stack.pop());
    }

    private static List<String> getListString(String suffixExpression) {
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<>();
        Arrays.stream(split).forEach(s -> list.add(s));
        return list;
    }
    
}
```

#### 完整的逆波兰计算器代码示例

```shell
# 这里代码太长了，略。有兴趣的可以自行 LeetCode 看看
```

## 递归

### 递归应用场景

```shell
# 例如: 迷宫问题（回溯）用到 递归（Recursion）
```

![UTOOLS1575943702672.png](https://img01.sogoucdn.com/app/a/100520146/28e82c9babd86cef983086fd03ec790d)

### 递归的概念

```shell
# 递归就是方法自己调用自己

# 每次调用时传入不同的变量

# 递归有助于编程者用简洁的代码解决复杂的问题
```

### 递归调用机制

![UTOOLS1575943845235.png](https://img01.sogoucdn.com/app/a/100520146/701068c6cfd6aa60ae83e6ffc982b0ea)

### 递归能解决什么样的问题

```shell
# 各种数学问题:
	# 8 皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题...
	
# 各种算法中也使用到了递归:
	# 快排、归并排序、二分查找、分治算法...
	
# 将用栈解决的问题 -> 变成递归代码比较简洁
```

### 递归需要遵守的重要规则

```shell
# 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）

# 方法的局部变量是独立的，不会互相影响，比如 n 变量

# 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据

# 递归必须向 退出递归的条件 逼近，否则就是无限递归，出现 StackOverflowError

# 当一个方法执行完毕，或者遇到 return，就会返回
	# 遵守谁调用，就将结果返回给谁
	# 同时当方法执行完毕或者返回时，该方法也就执行完毕
```

### 迷宫问题

#### 示例图

![UTOOLS1575945659858.png](https://img01.sogoucdn.com/app/a/100520146/e7e8ded6e23aa34ceaabfc1afcfa15b7)

#### 代码示例

```java
public class MiGong {

    public static void main(String[] args) {
        // 二维数组，模拟迷宫地图
        int[][] map = new int[8][7];
        // 使用 1 表示墙，上下左右全部置为 1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        // 设置挡板
        map[3][1] = 1;
        map[3][2] = 1;
        map[1][2] = 1;
        map[2][2] = 1;

        System.out.println("地图情况 --- ");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        setWay(map, 2, 4);

        System.out.println("小球走过，并标识过的地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }


    }

    /**
     * 走迷宫
     * 0: 没有走过 | 1: 表示墙 | 2: 表示通路可以走 | 3: 表示该点已经走过，但是走不通
     * 策略: 下 -> 右 -> 上 -> 左
     * @param map : 地图
     * @param i : 从哪个位置开始找（横坐标）
     * @param j : 从哪个位置开始找（纵坐标）
     * @return  : 找到路就返回 true，否则 false
     */
    private static boolean setWay(int[][] map, int i, int j) {

        if (map[6][5] == 2) return true;
        else {
            if (map[i][j] == 0) { // 如果该点还没有走过
                map[i][j] = 2; // 假设该点可以走通
                if (setWay(map, i+1, j)) return true;
                else if (setWay(map, i,j+1)) return true;
                else if (setWay(map, i-1, j)) return true;
                else if (setWay(map, i, j-1)) return true;
                else {
                    map[i][j] = 3;
                    return false;
                }
            } else {    // 如果 map[i][j] != 0 ，可能是 1,2,3
                return false;
            }
        }
    }

}
```

### 八皇后问题

#### 八皇后问题介绍

```shell
# 八皇后问题: 回溯算法的典型案例
	# 在 8 X 8 格的国际象棋上拜访 8 个皇后，使其不能互相攻击
	# 即: 任意两个皇后都不能处于同一行、同一列、同一斜线上，问有多少种摆法
```

#### 思路分析

```shell
# 第一个皇后先放第一行第一列

# 第二个皇后放在第二行第一列、然后判断是否 OK，如果不 OK，继续放在第二列、第三列、依次类推，直到合适

# 继续第三个皇后、还是第一列、第二列... 直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正解

# 当得到一个正解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到

# 然后回头继续第一个皇后放第二列，后面循序执行上述步骤
```

#### 说明

```shell
# 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法
	# 用一个一维数组即可解决问题: arr[8] = {0, 4, 7, 5, 2, 6, 1, 3}
	# 对应 arr 下标，表示第几行，即第几个皇后
	# arr[i] = val，val 表示第 i+1 个皇后，放在第 i+1 行的第 var + 1 列
```

#### 代码实例

```java
public class Queue8 {

    // 八皇后
    int max = 8;
    // 皇后放置位置的结果，例: arr = {0, 4, 7, 5, 2, 6, 1, 3}
    int[] array = new int[max];

    static int count = 0;
    static int judgeCount = 0;

    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.printf("一共有 %d 种解法", count);
        System.out.printf("一共判断冲突的次数 %d 次", judgeCount);
    }

    /**
     * 递归放置皇后
     * @param n : 第 n 个皇后
     */
    private void check(int n) {
        // 判断是否第 8 个皇后
        if(n == max) {
            print();
            return;
        }

        // 依次放入皇后，并判断是否冲突
        for (int i = 0; i < max; i++) {
            // 先把当前皇后 n 放入该行的第一列
            array[n] = i;
            // 判断当放置第 n 个皇后到 i 列时，是否冲突
            // 如果不冲突，接着放第 n+1 个皇后
            if (judge(n)) check(n + 1);
        }
    }

    /**
     * 当放置第 n 个皇后，检测该皇后是否和前面已经摆放的皇后冲突
     * @param n : 第 n 个皇后
     * @return : 冲突返回 false，否则 true
     * 说明:
     *  array[i] == array[n] : 判断当前第 n 个皇后是否和前一个 n-1 皇后在同一列
     *  Math.abs(n - i) == Math.abs(array[n] - array[i]) 表示判断第 n 个皇后是否和第 i 个皇后在同一斜线上
     */
    private boolean judge(int n) {
        judgeCount++;
        for (int i = 0; i < n; i++) {
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) return false;
        }
        return true;
    }

    /**
     * 输出皇后摆放的位置
     */
    private void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }

}
```

## 排序算法

### 排序算法的介绍

```shell
# Sort Algorithm :
	# 将一组数据，依指定的顺序进行排列的过程。
```

### 排序的分类

```shell
# 内部排序:
	# 指将需要处理的所有数据都加载到 内存 中进行排序。
	
# 外部排序:
	# 数据量过大，无法全部加载到内存中，需要借助 外部存储文件 进行排序。
	
# 常见的排序算法分类图示:
```

![UTOOLS1575957042259.png](https://img03.sogoucdn.com/app/a/100520146/ddd304ad218050cc0eee373f9747c83b)

### 算法的时间复杂度

#### 度量一个程序（算法）执行时间的两种方法

```shell
# 事后统计:
	# 方法可行，但是有两个问题:
		# 1. 需要实际运行程序
		# 2. 需要在同台计算机相同状态运行不同算法，才能比较哪个算法更快

# 事前估算:
	# 通过分析某个算法的 时间复杂度 来判断哪个算法更优
```

#### 时间频度

##### 基本介绍

```shell
# 时间频度:
	# 一个算法花费的时间与算法中语句的执行次数成正比
	# 所以一个算法中的语句执行次数，被称为 语句频度 或 时间频度
	# 记为 T(n)
```

##### 举例说明 - 基本案例

```java

int total = 0;
int end = 100;

// 时间频度 T(n) = n + 1;
for (int i = 1; i <= end; i++) {
  total += i;
}

// 时间频度 T(n) = 1;
total = (1+end) * end / 2;
```

##### 举例说明 - 忽略常数项

![UTOOLS1575958089977.png](https://img01.sogoucdn.com/app/a/100520146/90774205911d04a808d2968113f91e0b)

```shell
# 结论:
	# 2n+20 和 2n 随着 n 变大，执行曲线无限接近，20 可以忽略。
	# 3n+10 和 3n 随着 n 变大，执行曲线无限接近，10 可以忽略
```

##### 举例说明 - 忽略低次项

![UTOOLS1575958276261.png](https://img03.sogoucdn.com/app/a/100520146/5ad314eabbf8e189f0ea9d612c12ac3f)

```shell
# 结论:
	# 2n^2+3n+10 和 2n^2 随着 n 变大，执行曲线无限接近，可以忽略 3n+10
	# n^2+5n+20 和 n^2 随着 n 变大，执行曲线无限接近，可以忽略 5n+20
```

##### 举例说明 - 忽略系数

![UTOOLS1575958474356.png](https://img04.sogoucdn.com/app/a/100520146/884fae2d38c3b2d1563a092655f8965b)

```shell
# 结论:
	# 随着 n 值变大，5n^2+7n 和 3n^2+2n，执行曲线重合，说明该情况下， 5 和 3 可以忽略
	# 而 n^3+5n 和 6n^3+4n，执行曲线分离，说明 多少次方 是关键
```

### 时间复杂度

```shell
# 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n) 表示

# 若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数
	# 则称 f(n) 是 T(n) 的同数量级函数
	# 记作 T(n) = O（f(n)）
	# 为算法的渐进事件复杂度，简称事件复杂度
	
# T(n) 不同，但时间复杂度可能相同。
	# 例: T(n)=n²+7n+6 与 T(n)=3n²+2n+2 
		# 它们的 T(n) 不同，但时间复杂度相同，都为 O(n²)
		
# 计算时间复杂度的方法:
	# 用常数 1 代替运行时间中的所有加法常数:
		# T(n)=n²+7n+6 	=>  T(n)=n²+7n+1
		
	# 修改后的运行次数函数中，只保留最高阶项:
		# T(n)=n²+7n+1  =>  T(n)=n²
		
	# 去除最高阶项的系数:
		# T(n)=3n²  =>  T(n)=n²  =>  O(n²)
```

#### 常见的时间复杂度

```shell
# 常数阶 : O(1)

# 对数阶 : O(log2n)

# 线性阶 : O(n)

# 线性对数阶 : O(nlog2n)

# 平方阶 : O(n^2)

# 立方阶 : O(n^3)

# k 次方阶 : O(n^k)

# 指数阶 : O(2^n)
```

##### 常见的时间复杂度图解

![UTOOLS1575961919454.png](https://img01.sogoucdn.com/app/a/100520146/622dd61edb222afe56e58864cbc68b3b)

##### 说明

```shell
# 常见的算法时间复杂度由小到大依次为:
	# O(1) < O(log2n) < O(n) < O(nlog2n) < 0(n^2) < O(n^3) < O(n^k) < O(2^n)
	# 随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
	
# 从图中可见，我们应该尽可能避免使用指数阶的算法
```

##### 常数阶 O(1)

```shell
# 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 O(1)
```

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

##### 对数阶 O(log2n)

```java
int i = 1;
while (i < n) {
  i = i * 2;
}
```

```shell
# 在 while 循环里面，每次都将 i * 2，距离 n 就越来越近了
	# 假设循环 x 次后，i >= 2，此时循环退出
  # 即: 2^x >= n ，那么 x = log2(n) < 2是底数，n是真数 >
  # 即: 代码循环 x 次结束，因此时间复杂度为 O(log2(n)) < i = i * 2，所以底数为 2 >
```

##### 线性阶 O(n)

```java
for (int i = 1; i <= n; ++i) {
  j = i;
  j++;
}
```

```shell
# for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的
	# 因此这类代码都可以用 O(n) 来表示它的复杂度
```

##### 线性对数阶 O(nlogN)

```java
for (int i = 1; i < n; i++) {
  i = 1;
  while (i < n){
    i + i * 2;
  }
}
```

```shell
# 线性对数阶 O(nlogN):
	# 将时间复杂度为 O(logN) 的代码循环 N 遍的话，那么它的时间复杂度就是 n * O(logN)
```

##### 平方阶 O(n²)

```java
for (int x = 1; i <= n; x++) {
  for (int i = 1; i <= n; i++) {
    j = i;
    j++;
  }
}
```

```shell
# 平方阶 O(n²):
	# 将 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)
	# 即 O(n²) 如果将其中一层循环的 n 改成 m，那它的时间复杂度就变成了 O(m * n)
	
# O(n³)、O(n^k) 参照理解就好
```

#### 平均时间复杂度和最坏时间复杂度

```shell
# 平均时间复杂度:
	# 指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
	
# 最坏时间复杂度:
	# 一般讨论的时间复杂度均是最坏情况下的时间复杂度。
	# 这样做的原因是:
		# 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限
		# 这就保证了算法的运行时间不会比最坏情况更长
		
# 平均时间复杂度和最坏时间复杂度是否一致，和算法有关，如下图示:
```

![UTOOLS1575965582212.png](https://img02.sogoucdn.com/app/a/100520146/c565305a4c2788ed43da30d01f467c8e)

