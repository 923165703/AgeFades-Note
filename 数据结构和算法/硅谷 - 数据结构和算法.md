# 硅谷 - 数据结构和算法

## 数据结构和算法内容介绍

### 几个经典的算法面试题

```shell
# 字符串匹配问题
	# str1 = "你快乐吗快乐吗快乐你乐吗"， str2 = "快乐你你你乐快吗你快乐吗"
		# 最快的速度匹配，str1 是否包含 str2，如果存在，就返回第一次出现的位置，如果没有，则返回 -1
	
	# 解决思路:
		# 暴力匹配
		# KMP 算法<部分匹配表>
```

```shell
# 汉诺塔游戏
	# 将 A 塔所有圆盘移动到 C 盘，并且小圆盘上不能放大圆盘，三个柱子之间一次只能移动一个圆盘。
```

![UTOOLS1575600574554.png](https://img01.sogoucdn.com/app/a/100520146/cdf9253c3623f8066a48440528a75923)

```shell
# 八皇后问题
	# 回朔算法的典型案例
	# 在 8x8 格的国际象棋上摆放八个皇后，使其不能互相攻击
	# 即: 任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
```

![UTOOLS1575600691256.png](https://img03.sogoucdn.com/app/a/100520146/d1374e90f3a35baf2d0ed942f2a7461c)

```shell
# 马踏棋盘<骑士周游>
	# 将马随机放在国际象棋的 8x8 棋盘的某个放个中，马走日进行移动，要求每个方格只进入一次，走遍棋盘上全部 64 个方格
	# 图的深度优化遍历算法<DFS> + 贪心算法优化
```

![UTOOLS1575600813113.png](https://img04.sogoucdn.com/app/a/100520146/1c12369b2be1b9b6940a000c70dc8353)

### 数据结构和算法的重要性

```shell
# 算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高度计算。
```

## 数据结构和算法概述

### 数据结构和算法的关系

```shell
# 数据结构是一门研究组织数据方式的学科

# 程序 = 数据结构 + 算法

# 数据结构是算法的基础
```

### 线性结构和非线性结构

```shell
# 数据结构包括:
	# 线性结构和非线性结构
```

#### 线性结构

```shell
# 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。

# 线性结构有两种不同的存储结构，即顺序存储结构<数组> 和链式存储结构<链表>。
	# 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。
	
	# 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。
	
# 常见的线性结构有:
	# 数组、队列、链表和栈。
```

#### 非线性结构

```shell
# 非线性结构包括:
	# 二维数组
	# 多维数组
	# 广义表
	# 树结构
	# 图结构
```

## 稀疏数组和队列

### 稀疏数组

#### 五子棋的问题

```shell
# 编写的五子棋程序中，有存盘退出和续上盘的功能。
```

![UTOOLS1575601280168.png](https://img02.sogoucdn.com/app/a/100520146/6d14f3f9d428798a01297d7913c53f65)

##### 问题分析

```shell
# 因为该二维数组的很多值都是默认值 0，因此记录了很多没有意义的数据 
```

#### 基本介绍

```shell
# 当一个数组中大部分元素为 0，或者为同一个值得数组时，可以使用稀疏数组来保存该数组。

# 稀疏数组的处理方法是:
	# 记录数组一共有几行几列，有多少个不同的值
	# 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小存储数据结构的规模
```

![UTOOLS1575601473254.png](https://img01.sogoucdn.com/app/a/100520146/8cb9d50ec316dd8d6fc6d0f521a89b79)

#### 思路分析

```shell
# 二维数组 转 稀疏数组的思路
	# 遍历原始的二维数组，得到有效数据的个数 sum ->
		# 根据 sum 就可以创建 稀疏数组 sparseArr int[sum+1][3] ->
		# 将二维数组的有效数据存入到稀疏数组
		
# 稀疏数组转原始的二维数组的思路
	# 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
	# 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可
```

#### 代码验证

```java
public class SparseArray {

    public static void main(String[] args) {
        // 创建一个原始的二维数组 11 * 11
        // 0: 表示没有棋子 1: 表示黑子 2: 表示蓝子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[4][5] = 2;

        // 输出原始数组
        Arrays.stream(chessArr1)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

        // 得到二维数组非 0 个数
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0) {
                    sum++;
                }
            }
        }

        // 将二维数组 转 稀疏数组
        int sparseArr[][] = new int[sum + 1][3];
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组，将非 0 的值存放到 sparseArr
        int count = 0; // 记录第几个非 0 数据
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }

        System.out.println("----------------------");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        System.out.println("----------------------");
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        Arrays.stream(chessArr2)
                .forEach(ints -> {
                    Arrays.stream(ints).forEach(data -> System.out.printf("%d\t", data));
                    System.out.println();
                });

    }

}
```

### 队列

#### 介绍

```shell
# 队列是一个有序列表，可以用 数组 或是 链表来实现

# 遵循 先入先出 的原则。

# 数组模拟队列示意图:
```

![UTOOLS1575610263678.png](https://img03.sogoucdn.com/app/a/100520146/ad34e99ce46f9b61e005e0872f82b7a5)

#### 数组模拟队列思路

```shell
# 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图
	# 其中 maxSize 是该队列的最大容量
	
# 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量
	# front 记录队列前端下标，会随着数据输出而改变
	# rear 记录队列后端的下标，而 rear 则是随着数据输入而改变
```

![UTOOLS1575611292864.png](https://img04.sogoucdn.com/app/a/100520146/be0ad51bf50e681cc155101f33573580)

```shell
# 当我们将数据存入队列时称为 "addQueue"
	# 将尾指针往后移: rear + 1，当 front == rear 【空】
	# 若尾指针 rear 小于队列的最大下标 maxSize-1 ->
		# 则将数据存入 rear 所指的数组元素中，否则无法存入数据 ->
		# rear == maxSize -1 【队列满】
```

```java
public class ArrayQueue {

    // 数组的最大容量
    private int maxSize;

    // 队列头
    private int front;

    // 队列尾
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public ArrayQueue(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; // 指向队列头部，分析出 front 是指向队列头的前一个位置
        rear = -1; // 指向队列尾，即队列最后一个数据
    }

    // 判断队列是否满
    public boolean isFull(){
        return rear == maxSize - 1;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        rear ++; // 尾指针后移
        arr[rear] = n;
    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        front ++; // 头指针后移
        return arr[front];
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front + 1];
    }

}
```

#### 问题分析并优化

```shell
# 目前数组使用一次就不能用，没有达到优化的效果

# 将这个数组改进成一个 环形的队列 <取模: %>
```

#### 思路分析

```shell
# 尾索引的下一个为头索引时表示队列满
	# 即将队列容量空出一个作为约定
	# 在做判断队列满的时候需要注意 
		# (rear + 1) % maxSize == front【满】
		# rear == front【空】
		
# 分析示意图:
```

![UTOOLS1575616062211.png](https://img01.sogoucdn.com/app/a/100520146/4a089304087b0e969b7471352245fc28)

##### 思路如下

```shell
# front 变量的含义做一个调整:
	# front 就指向队列的第一个元素，也就是说 arr[front] 就是队列的第一个元素，初始值为 0
	
# rear 变量的含义做一个调整:
	# rear 指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定
	# read 的初始值为 0
	
# 当队列满时，条件是(rear + 1) % maxSize = front【满】

# 当队列为空时，rear == front【空】

# 队列中有效的数据个数:
	# (rear + maxSize - front) % maxSize
	# rear = 1，front = 0
	
# 这样在原来的队列上修改得到，一个环形队列
```

```java
public class CircleArray {

    // 数组的最大容量
    private int maxSize;

    // 队列头，初始值为 0
    private int front;

    // 队列尾，初始值为 0
    private int rear;

    // 存放数据，模拟队列容器
    private int[] arr;

    // 创建队列的构造器
    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    // 判断队列是否满
    public boolean isFull(){
        return (rear + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("the queue is full");
            return;
        }
        // 加入数据
        arr[rear] = n;
        // 移动 rear 指针
        rear = (rear + 1) % maxSize;

    }

    // 获取队列的数据
    public int getQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 遍历队列
    public void showQueue(){
        if (isEmpty()){
            System.out.println("the queue is empty");
            return;
        }
        for (int i = front; i < front + size(); i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    // 显示队列的头数据
    public int headQueue(){
        if (isEmpty())
            throw new RuntimeException("the queue is empty");
        return arr[front % maxSize];
    }

    // 当前队列有效数据的个数
    public int size(){
        return (rear + maxSize - front) % maxSize;
    }

}
```

## 链表

### 介绍

```shell
# 链表是有序的列表，但是它在内存中是存储如下:
```

![UTOOLS1575617283864.png](https://img01.sogoucdn.com/app/a/100520146/e970726ccadf5d64d579da7a3719a2a3)

```shell
# 链表是以节点的方式来存储，是链式存储

# 每个节点包含 data 域，next 域<指向下一个节点>

# 链表的各个节点不一定是连续存储

# 链表分 带头节点的链表 和 没有头节点的链表
```

#### 带头节点逻辑示意图

![UTOOLS1575617501182.png](https://img03.sogoucdn.com/app/a/100520146/4ae1eea1f7e8fba92f736a0ecd2af09b)

### 单链表的应用实例

```java
public class SingleLinkedList {

    // 初始化一个虚拟头结点
    private HeroNode head = new HeroNode(0,"");

    // 不考虑编号顺序，直接添加到单链表的最后节点
    public void add(HeroNode node) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null)
                break;
            temp = temp.next;
        }
        temp.next = node;
    }

    // 根据排名将英雄插入到指定位置，如有这个排名，则添加失败
    public void addByOrder(HeroNode node) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no > node.no)
                break;
            else if (temp.next.no == node.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            System.out.printf("%d 已存在，不能加入\n", node.no);
        else {
            node.next = temp.next;
            temp.next = node;
        }
    }

    // 根据 no 编号修改节点信息
    public void update(HeroNode node) {
        if (isEmpty())
            throw new RuntimeException("the likedList is empty");
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp == null)
                break;
            if (temp.no == node.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.name = node.name;
        else
            throw new RuntimeException("the node was not found");
    }

    // 删除节点
    public void del(int no) {
        HeroNode temp = head;
        boolean flag = false;
        while (true) {
            if (temp.next == null)
                break;
            if (temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag)
            temp.next = temp.next.next;
        else
            throw new RuntimeException("the node was not found");
    }

    // 显示链表
    public void showList(){
        if (isEmpty()n
            throw new RuntimeException("the linkedList is empty");
        HeroNode temp = head.next;
        while(true) {
            if (temp == null)
                break;
            System.out.println(temp);
            temp = temp.next;
        }
    }

    // 判断链表是否为空
    public boolean isEmpty(){
        return head.next == null;
    }

}

class HeroNode {

    public int no;
    public String name;
    public HeroNode next;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 单链表面试题

#### 求单链表中有效节点的个数

```java
/**
 * 获取到单链表的节点的个数<如果是带头结点的链表，需求不统计头节点>
 * @param head : 链表的头结点
 * @return : 返回有效节点的个数
 */
public static int getLength(HeroNode head) {
  	if (head.next == null)
    	return 0;
  
 	  int length = 0;
  	HeroNode cur = head.next;
    while (cur != null) {
      length++;
      cur = cur.next;
    }
  
  	return length;
}
```

#### 查找单链表中的倒数第 k 个节点

```java
/**
 * param : 参数接收 head 节点，同时接收一个 index
 * 思路 : 先从头到尾遍历节点，得到链表的总长度
 *				 size - index 即倒数第 k 个节点
 */
public static HeroNode findLastIndexNode(HeroNode head, int index) {
  	// 判断如果链表为空，返回 null
  	if (isEmpty())
      throw new RuntimeException("the linkedList is empty");
  	// 获取链表长度
  	int size = getLength(head);
  	// index 值校验
    if (index <= 0 || index > size)
      throw new RuntimeException("the index is illegal");
  
  	HeroNode cur = head.next;
   	for (int i = 0; i < size - index; i++) {
      cur = cur.next;
    }
  	return cur;
}
```

#### 单链表的反转

```shell
# 思路:
	# 先定义一个节点 reverseHead
	# 从头到尾遍历链表，每遍历一个节点，
```

